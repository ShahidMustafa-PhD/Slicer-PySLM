import os
from pathlib import Path

MAIN = Path(r'c:\Active_Projects\Slicer-PySLM\src\presentation\main_window.py')

with open(MAIN, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Keep lines 1-1413 (indices 0-1412) - verified clean
clean_head = lines[:1413]

# Keep dialog functions lines 1556-1755 (indices 1555-1754) - verified clean
clean_dialogs = lines[1555:1755]

# Build the middle section as a list of lines
mid = []
mid.append('')
mid.append('    def _on_dir_selected(self, sender, app_data, user_data) -> None:')
mid.append('        self._navigate_to(Path(user_data))')
mid.append('')
mid.append('    def _on_quick_link_click(self, sender, app_data, user_data) -> None:')
mid.append('        self._navigate_to(Path(user_data))')
mid.append('')
mid.append('    def _load_asset_file(self, sender, app_data, user_data) -> None:')
mid.append('        file_path = Path(user_data)')
mid.append('        if not file_path.exists():')
mid.append('            self._set_status(f"File removed: {file_path.name}")')
mid.append('            return')
mid.append('        self._set_status(f"Loading {file_path.name} ...")')
mid.append('        try:')
mid.append('            name, mesh = self.loader.load(str(file_path))')
mid.append('        except AssetLoadError as exc:')
mid.append('            self._set_status(f"Load error: {exc}")')
mid.append('            dpg.set_value("info_text", str(exc))')
mid.append('            return')
mid.append('')
mid.append('        self.scene.add_mesh(name, mesh, source_path=str(file_path))')
mid.append('        info = (')
mid.append('            f"Loaded: {name}\\n"')
mid.append('            f"Vertices : {mesh.vertices.shape[0]:,}\\n"')
mid.append('            f"Faces    : {mesh.faces.shape[0]:,}\\n"')
mid.append('            f"Size     : {mesh.extents.round(2)} mm"')
mid.append('        )')
mid.append('        dpg.set_value("info_text", info)')
mid.append('        self._set_status(')
mid.append('            f"Imported {name} ({mesh.faces.shape[0]:,} triangles)"')
mid.append('        )')
mid.append('        self._refresh_all()')
mid.append('')
mid.append('    def _quick_links(self) -> list[tuple[str, Path]]:')
mid.append('        home = Path.home()')
mid.append('        links = []')
mid.append('        candidates = [')
mid.append('            ("Home", home),')
mid.append('            ("Desktop", home / "Desktop"),')
mid.append('            ("Documents", home / "Documents"),')
mid.append('            ("Downloads", home / "Downloads"),')
mid.append('        ]')
mid.append('        for label, path in candidates:')
mid.append('            if path.exists():')
mid.append('                links.append((label, path))')
mid.append('        if os.name == "nt":')
mid.append('            roots = [Path(f"{chr(letter)}:/") for letter in range(67, 70)]')
mid.append('            links.extend((f"Drive {root.drive}", root) for root in roots if root.exists())')
mid.append('        return links')
mid.append('')
mid.append('    # =====================================================================')
mid.append('    #  Sidebar sync')
mid.append('    # =====================================================================')
mid.append('    def _on_object_list_select(self, sender, app_data) -> None:')
mid.append('        label = app_data')
mid.append('        for obj in self.scene.objects:')
mid.append('            if f"[{obj.uid}] {obj.name}" == label:')
mid.append('                self.scene.select(obj.uid)')
mid.append('                self._refresh_sidebar()')
mid.append('                self.viewport.rebuild_scene()')
mid.append('                return')
mid.append('')
mid.append('    def _on_transform_change(self, sender=None, app_data=None) -> None:')
mid.append('        obj = self.scene.selected_object')
mid.append('        if obj is None:')
mid.append('            return')
mid.append('        self.scene.set_transform(')
mid.append('            obj.uid,')
mid.append('            translation=np.array(dpg.get_value("tf_pos"), dtype=np.float64),')
mid.append('            rotation_deg=np.array(dpg.get_value("tf_rot"), dtype=np.float64),')
mid.append('            scale=np.array(dpg.get_value("tf_scale"), dtype=np.float64),')
mid.append('            record_undo=True,')
mid.append('        )')
mid.append('        self.viewport.rebuild_scene()')
mid.append('        self._check_build_volume()')
mid.append('')
mid.append('    def _refresh_sidebar(self) -> None:')
mid.append('        items = [f"[{o.uid}] {o.name}" for o in self.scene.objects]')
mid.append('        dpg.configure_item("object_list", items=items)')
mid.append('')
mid.append('        obj = self.scene.selected_object')
mid.append('        if obj:')
mid.append('            dpg.set_value("tf_pos",   list(obj.transform.translation))')
mid.append('            dpg.set_value("tf_rot",   list(obj.transform.rotation_deg))')
mid.append('            dpg.set_value("tf_scale", list(obj.transform.scale))')
mid.append('        else:')
mid.append('            dpg.set_value("tf_pos",   [0, 0, 0])')
mid.append('            dpg.set_value("tf_rot",   [0, 0, 0])')
mid.append('            dpg.set_value("tf_scale", [1, 1, 1])')
mid.append('')
mid.append('    def _refresh_all(self) -> None:')
mid.append('        self._refresh_sidebar()')
mid.append('        self._update_counters()')
mid.append('        self.viewport.rebuild_scene()')
mid.append('        self._check_build_volume()')
mid.append('')
mid.append('    # =====================================================================')
mid.append('    #  Status / counters')
mid.append('    # =====================================================================')
mid.append('    def _set_status(self, msg: str) -> None:')
mid.append('        if not dpg.does_item_exist("status_text"):')
mid.append('            return')
mid.append('        plate = self.scene.build_plate')
mid.append('        txt = (')
mid.append('            f"{msg}   \\u00b7   "')
mid.append('            f"Objects: {self.scene.object_count}   \\u00b7   "')
mid.append('            f"Build plate: \\u00d8{plate.diameter_mm:.0f} mm"')
mid.append('        )')
mid.append('        dpg.set_value("status_text", txt)')
mid.append('')
mid.append('    def _update_counters(self) -> None:')
mid.append('        total_tris = sum(o.mesh.faces.shape[0] for o in self.scene.objects)')
mid.append('        dpg.set_value("vp_obj_count", f"Objects: {self.scene.object_count}")')
mid.append('        dpg.set_value("vp_tri_count", f"Triangles: {total_tris:,}")')
mid.append('')
mid.append('        # Update job specs (Cura JobSpecs.qml)')
mid.append('        obj = self.scene.selected_object')
mid.append('        if obj:')
mid.append('            dpg.set_value("job_filename", obj.name)')
mid.append('            dpg.set_value("job_faces", f"{obj.mesh.faces.shape[0]:,} faces")')
mid.append('        else:')
mid.append('            dpg.set_value("job_filename", "")')
mid.append('            dpg.set_value("job_faces", "")')
mid.append('')
mid.append('    # =====================================================================')
mid.append('    #  Build volume validation')
mid.append('    # =====================================================================')
mid.append('    def _check_build_volume(self) -> None:')
mid.append('        # Check if any objects violate the build volume and update warnings.')
mid.append('        issues = self.scene.check_build_volume()')
mid.append('        if issues:')
mid.append('            msg = f"\\u26a0 {len(issues)} object(s) outside build volume"')
mid.append('            dpg.set_value("info_text", msg)')
mid.append('')

# Build the tail section
tail = []
tail.append('')
tail.append('    def _cmd_marketplace(self, sender=None, app_data=None) -> None:')
tail.append('        if dpg.does_item_exist("mkt_popup"):')
tail.append('            dpg.delete_item("mkt_popup")')
tail.append('        with dpg.window(label="Marketplace", modal=True,')
tail.append('                        tag="mkt_popup", width=420, height=200):')
tail.append('            dpg.add_text("PySLM Extension Marketplace", color=C.ACCENT)')
tail.append('            dpg.add_separator()')
tail.append('            dpg.add_text(')
tail.append('                "The marketplace allows you to discover and install\\n"')
tail.append('                "community plugins for PySLM Slicer.\\n\\n"')
tail.append('                "No plugins are currently available.\\n"')
tail.append('                "Check back in future versions for:\\n"')
tail.append('                "  \\u2022 Advanced hatching strategies\\n"')
tail.append('                "  \\u2022 Custom material database\\n"')
tail.append('                "  \\u2022 Cloud-based build monitoring",')
tail.append('                color=C.TEXT_MEDIUM, wrap=390,')
tail.append('            )')
tail.append('            dpg.add_spacer(height=6)')
tail.append('            close_btn = dpg.add_button(label="  Close  ",')
tail.append('                                       callback=lambda: dpg.delete_item("mkt_popup"))')
tail.append('            dpg.bind_item_theme(close_btn, self._th_secondary)')
tail.append('')
tail.append('    def _gather_slice_params(self) -> dict:')
tail.append('        return {')
tail.append('            "layer_thickness":       dpg.get_value("param_layer_thickness"),')
tail.append('            "laser_power":           dpg.get_value("param_laser_power"),')
tail.append('            "scan_speed":            dpg.get_value("param_scan_speed"),')
tail.append('            "hatch_spacing":         dpg.get_value("param_hatch_spacing"),')
tail.append('            "hatch_angle_increment": dpg.get_value("param_hatch_angle"),')
tail.append('            "contour_count":         dpg.get_value("param_contour_count"),')
tail.append('            "contour_offset":        dpg.get_value("param_contour_offset"),')
tail.append('            "island_scanning":       dpg.get_value("param_island"),')
tail.append('            "island_size":           dpg.get_value("param_island_size"),')
tail.append('        }')
tail.append('')

# Assemble
content = ''.join(clean_head) + '\n'.join(mid) + '\n' + ''.join(clean_dialogs) + '\n'.join(tail) + '\n'

with open(MAIN, 'w', encoding='utf-8') as f:
    f.write(content)

print(f'Done! Written {len(content.splitlines())} lines')
